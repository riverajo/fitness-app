package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	model1 "github.com/riverajo/fitness-app/backend/graph/model"
	"github.com/riverajo/fitness-app/backend/internal/middleware"
	internalModel "github.com/riverajo/fitness-app/backend/internal/model"
	"golang.org/x/crypto/bcrypt"
)

// CreateWorkoutLog is the resolver for the createWorkoutLog field.
func (r *mutationResolver) CreateWorkoutLog(ctx context.Context, input model1.CreateWorkoutLogInput) (*internalModel.WorkoutLog, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to create a workout log")
	}
	userID := userIDVal.(string)

	// 2. Map input to internal model
	// Note: We still need to map Input -> Internal Model because Inputs are generated in graph/model
	// and Domain Models are in internal/model. Auto-bind only handles Output types.
	var internalExerciseLogs []*internalModel.ExerciseLog
	for _, el := range input.ExerciseLogs {
		var internalSets []*internalModel.Set
		for _, s := range el.Sets {
			internalSets = append(internalSets, &internalModel.Set{
				Reps:      s.Reps,
				Weight:    s.Weight,
				Rpe:       s.Rpe,
				ToFailure: s.ToFailure,
				Order:     s.Order,
			})
		}
		internalExerciseLogs = append(internalExerciseLogs, &internalModel.ExerciseLog{
			UniqueExerciseID: el.UniqueExerciseID,
			Sets:             internalSets,
			Notes:            el.Notes,
		})
	}

	internalLog := internalModel.WorkoutLog{
		UserID:       userID,
		Name:         input.Name,
		StartTime:    input.StartTime,
		EndTime:      input.EndTime,
		ExerciseLogs: internalExerciseLogs,
		LocationName: input.LocationName,
		GeneralNotes: input.GeneralNotes,
	}

	// 3. Call Service
	createdLog, err := r.WorkoutService.CreateLog(ctx, internalLog)
	if err != nil {
		return nil, fmt.Errorf("failed to create workout log: %w", err)
	}

	// 4. Return the internal model directly! Auto-bind handles the rest.
	// We do NOT need to map back to model1.WorkoutLog or fetch the User manually here.
	// gqlgen will use the User resolver (if defined) or field (if present) on the struct.
	// Since internalModel.WorkoutLog doesn't have a `User *User` field (it has UserID),
	// we need a resolver for the `user` field on WorkoutLog.
	return createdLog, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model1.RegisterInput) (*model1.AuthPayload, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to process password: %w", err)
	}
	internalUser := internalModel.NewUser(input.Email, string(hashedPassword))
	// 1. Call the UserService to handle hashing and database insertion.
	err = r.UserService.CreateUser(ctx, *internalUser)

	if err != nil {
		// Log the error for internal diagnostics, but return a generic message to the client for security.
		fmt.Printf("Registration failed for email %s: %v\n", input.Email, err)

		// ðŸ’¡ Check for the "user already exists" error (if we want a specific front-end message)
		if err.Error() == fmt.Sprintf("user with email %s already exists", input.Email) {
			return nil, fmt.Errorf("this email is already registered")
		}

		return nil, fmt.Errorf("failed to register user")
	}

	// 2. Registration successful, but we don't handle login/cookie creation here.
	// The client knows registration succeeded. They should call the 'login' mutation next.
	return &model1.AuthPayload{
		Success: true,
		Message: "Registration successful. Please log in.",
		User:    internalUser, // Return internal user directly
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model1.LoginInput) (*model1.AuthPayload, error) {
	// ... (User verification logic remains the same) ...
	user, err := r.UserService.VerifyPassword(ctx, input.Email, input.Password)
	if err != nil {
		return nil, fmt.Errorf("invalid login credentials")
	}

	// 1. Generate the JWT token
	token, err := middleware.GenerateJWT(user)
	if err != nil { /* ... handle error ... */
		log.Printf("CRITICAL: Failed to generate JWT for user %s: %v", user.ID, err)
		return nil, fmt.Errorf("internal server error during session creation")
	}

	// 2. GET THE RESPONSE WRITER FROM CONTEXT
	w := middleware.GetResponseWriter(ctx)
	if w == nil {
		// Log this critical error internally
		return nil, fmt.Errorf("internal server error: response writer not available")
	}

	// 3. SET THE SECURE HTTP-ONLY COOKIE
	expirationTime := time.Now().Add(24 * time.Hour)
	cookie := http.Cookie{
		Name:     middleware.AuthCookieName,
		Value:    token,
		Expires:  expirationTime,
		HttpOnly: true,                    // Prevents JavaScript access (XSS mitigation)
		Secure:   true,                    // CRITICAL: Only send over HTTPS
		SameSite: http.SameSiteStrictMode, // Prevents CSRF
		Path:     "/",
	}
	http.SetCookie(w, &cookie)

	// 4. Return successful payload
	return &model1.AuthPayload{
		Success: true,
		Message: "Login successful. Token set in cookie.",
		User:    user, // Return internal user directly
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model1.UpdateUserInput) (*model1.AuthPayload, error) {
	// 1. Ensure user is authenticated
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to update profile")
	}
	userID := userIDVal.(string)

	// ðŸ’¡ STEP 2 (ADAPTER): Map the GraphQL-generated input to the internal, decoupled input model
	internalInput := internalModel.UserUpdateInput{
		CurrentPassword: &input.CurrentPassword,
		NewPassword:     input.NewPassword,
		PreferredUnit:   input.PreferredUnit,
	}

	// 3. Call the UserService with the internal model
	updatedUser, err := r.UserService.UpdateUser(ctx, userID, internalInput)
	if err != nil {
		// This handles "invalid current password" and other service errors
		return nil, err
	}

	// 4. Return successful payload
	return &model1.AuthPayload{
		Success: true,
		Message: "User profile updated successfully.",
		User:    updatedUser, // Return internal user directly
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model1.AuthPayload, error) {
	// 1. Get the ResponseWriter from context
	w := middleware.GetResponseWriter(ctx)
	if w == nil {
		return nil, fmt.Errorf("internal server error: response writer not available")
	}

	// 2. Set the cookie with MaxAge -1 to delete it
	http.SetCookie(w, &http.Cookie{
		Name:     middleware.AuthCookieName,
		Value:    "",
		Path:     "/",
		MaxAge:   -1,
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteStrictMode,
	})

	// 3. Return success
	return &model1.AuthPayload{
		Success: true,
		Message: "Logged out successfully.",
	}, nil
}

// CreateUniqueExercise is the resolver for the createUniqueExercise field.
func (r *mutationResolver) CreateUniqueExercise(ctx context.Context, input model1.CreateUniqueExerciseInput) (*internalModel.UniqueExercise, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to create a custom exercise")
	}
	userID := userIDVal.(string)

	// 2. Call Service
	return r.ExerciseService.CreateExercise(ctx, input.Name, input.Description, &userID)
}

// GetWorkoutLog is the resolver for the getWorkoutLog field.
func (r *queryResolver) GetWorkoutLog(ctx context.Context, id string) (*internalModel.WorkoutLog, error) {
	// 1. Fetch from service
	log, err := r.WorkoutService.GetLog(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch workout log: %w", err)
	}
	return log, nil
}

// ListWorkoutLogs is the resolver for the listWorkoutLogs field.
func (r *queryResolver) ListWorkoutLogs(ctx context.Context) ([]*internalModel.WorkoutLog, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to list workout logs")
	}
	userID := userIDVal.(string)

	// 2. Fetch from service
	logs, err := r.WorkoutService.ListLogs(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list workout logs: %w", err)
	}
	return logs, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*internalModel.User, error) {
	// Use internalModel.User for output

	// 1. Extract the user ID from the context (injected by AuthMiddleware)
	userIDVal := ctx.Value(middleware.UserIDKey)

	// Check if the user ID exists in the context (i.e., user is authenticated)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: authentication required")
	}

	// Assert the type back to a string
	userID, ok := userIDVal.(string)
	if !ok {
		// This should not happen if the middleware is correct, but safe check is good.
		return nil, fmt.Errorf("internal server error: invalid user ID in context")
	}

	// 2. Call the UserService to fetch the complete user entity
	internalUser, err := r.UserService.GetUserByID(ctx, userID)
	if err != nil {
		// Handle "user not found" or database errors
		return nil, fmt.Errorf("failed to retrieve user details: %w", err)
	}

	// 3. Return the internal model directly
	return internalUser, nil
}

// SearchExercises is the resolver for the searchExercises field.
func (r *queryResolver) SearchExercises(ctx context.Context, query string) ([]*internalModel.UniqueExercise, error) {
	// 1. Get UserID from context (optional, but needed to see custom exercises)
	var userID *string
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal != nil {
		uid := userIDVal.(string)
		userID = &uid
	}

	// 2. Call Service
	return r.ExerciseService.SearchExercises(ctx, userID, query)
}

// IsCustom is the resolver for the isCustom field.
func (r *uniqueExerciseResolver) IsCustom(ctx context.Context, obj *internalModel.UniqueExercise) (bool, error) {
	return obj.UserID != nil, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// UniqueExercise returns UniqueExerciseResolver implementation.
func (r *Resolver) UniqueExercise() UniqueExerciseResolver { return &uniqueExerciseResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type uniqueExerciseResolver struct{ *Resolver }
