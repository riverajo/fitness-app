package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"

	model1 "github.com/riverajo/fitness-app/backend/graph/model"
	"github.com/riverajo/fitness-app/backend/internal/middleware"
	internalModel "github.com/riverajo/fitness-app/backend/internal/model"
	"golang.org/x/crypto/bcrypt"
)

// UniqueExercise is the resolver for the uniqueExercise field.
func (r *exerciseLogResolver) UniqueExercise(ctx context.Context, obj *internalModel.ExerciseLog) (*internalModel.UniqueExercise, error) {
	return r.ExerciseService.GetExercise(ctx, obj.UniqueExerciseID)
}

// CreateWorkoutLog is the resolver for the createWorkoutLog field.
func (r *mutationResolver) CreateWorkoutLog(ctx context.Context, input model1.CreateWorkoutLogInput) (*internalModel.WorkoutLog, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to create a workout log")
	}
	userID := userIDVal.(string)

	// 2. Map input to internal model
	// Note: We still need to map Input -> Internal Model because Inputs are generated in graph/model
	// and Domain Models are in internal/model. Auto-bind only handles Output types.
	var internalExerciseLogs []*internalModel.ExerciseLog
	for _, el := range input.ExerciseLogs {
		var internalSets []*internalModel.Set
		for _, s := range el.Sets {
			internalSets = append(internalSets, &internalModel.Set{
				Reps:      s.Reps,
				Weight:    s.Weight,
				Rpe:       s.Rpe,
				ToFailure: s.ToFailure,
				Order:     s.Order,
			})
		}
		internalExerciseLogs = append(internalExerciseLogs, &internalModel.ExerciseLog{
			UniqueExerciseID: el.UniqueExerciseID,
			Sets:             internalSets,
			Notes:            el.Notes,
		})
	}

	internalLog := internalModel.WorkoutLog{
		UserID:       userID,
		Name:         input.Name,
		StartTime:    input.StartTime,
		EndTime:      input.EndTime,
		ExerciseLogs: internalExerciseLogs,
		LocationName: input.LocationName,
		GeneralNotes: input.GeneralNotes,
	}

	// 3. Call Service
	createdLog, err := r.WorkoutService.CreateLog(ctx, internalLog)
	if err != nil {
		return nil, fmt.Errorf("failed to create workout log: %w", err)
	}

	// 4. Return the internal model directly! Auto-bind handles the rest.
	// We do NOT need to map back to model1.WorkoutLog or fetch the User manually here.
	// gqlgen will use the User resolver (if defined) or field (if present) on the struct.
	// Since internalModel.WorkoutLog doesn't have a `User *User` field (it has UserID),
	// we need a resolver for the `user` field on WorkoutLog.
	return createdLog, nil
}

// UpdateWorkoutLog is the resolver for the updateWorkoutLog field.
func (r *mutationResolver) UpdateWorkoutLog(ctx context.Context, input model1.UpdateWorkoutLogInput) (*internalModel.WorkoutLog, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to update a workout log")
	}
	userID := userIDVal.(string)

	// 2. Fetch existing log to verify ownership
	existingLog, err := r.WorkoutService.GetLog(ctx, input.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch workout log: %w", err)
	}
	if existingLog.UserID != userID {
		return nil, fmt.Errorf("unauthorized: you do not own this workout log")
	}

	// 3. Map input to internal model (handling partial updates if needed, but here we replace fields if provided)
	// Since input fields are pointers (optional), we check if they are non-nil.
	// For exerciseLogs, if provided, we REPLACE the list.

	updatedLog := *existingLog

	if input.Name != nil {
		updatedLog.Name = *input.Name
	}
	if input.StartTime != nil {
		updatedLog.StartTime = *input.StartTime
	}
	if input.EndTime != nil {
		updatedLog.EndTime = *input.EndTime
	}
	if input.LocationName != nil {
		updatedLog.LocationName = input.LocationName
	}
	if input.GeneralNotes != nil {
		updatedLog.GeneralNotes = input.GeneralNotes
	}

	if input.ExerciseLogs != nil {
		var internalExerciseLogs []*internalModel.ExerciseLog
		for _, el := range input.ExerciseLogs {
			var internalSets []*internalModel.Set
			for _, s := range el.Sets {
				internalSets = append(internalSets, &internalModel.Set{
					Reps:      s.Reps,
					Weight:    s.Weight,
					Rpe:       s.Rpe,
					ToFailure: s.ToFailure,
					Order:     s.Order,
				})
			}
			internalExerciseLogs = append(internalExerciseLogs, &internalModel.ExerciseLog{
				UniqueExerciseID: el.UniqueExerciseID,
				Sets:             internalSets,
				Notes:            el.Notes,
			})
		}
		updatedLog.ExerciseLogs = internalExerciseLogs
	}

	// 4. Call Service
	result, err := r.WorkoutService.UpdateLog(ctx, updatedLog)
	if err != nil {
		return nil, fmt.Errorf("failed to update workout log: %w", err)
	}

	return result, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model1.RegisterInput) (*model1.AuthPayload, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to process password: %w", err)
	}
	internalUser := internalModel.NewUser(input.Email, string(hashedPassword))
	// 1. Call the UserService to handle hashing and database insertion.
	err = r.UserService.CreateUser(ctx, *internalUser)

	if err != nil {
		// Log the error for internal diagnostics, but return a generic message to the client for security.
		fmt.Printf("Registration failed for email %s: %v\n", input.Email, err)

		// ðŸ’¡ Check for the "user already exists" error (if we want a specific front-end message)
		if err.Error() == fmt.Sprintf("user with email %s already exists", input.Email) {
			return nil, fmt.Errorf("this email is already registered")
		}

		return nil, fmt.Errorf("failed to register user")
	}

	// 2. Registration successful.
	//    Generate the JWT token to return to the client.

	// 2a. Generate the JWT token
	token, err := middleware.GenerateJWT(internalUser, r.JWTSecret)
	if err != nil {
		slog.Error("CRITICAL: Failed to generate JWT for new user", "user_id", internalUser.ID, "error", err)
		return nil, fmt.Errorf("registration successful, but failed to generate token")
	}

	// 2b. Generate and Set Refresh Token
	refreshToken, err := r.TokenService.CreateCompositeRefreshToken(ctx, internalUser.ID)
	if err != nil {
		slog.Error("Failed to generate refresh token", "error", err)
		// We can still return success, but client won't have refresh capability.
		// Ideally we should fail or warn. For now, let's log error.
	} else {
		http.SetCookie(middleware.GetResponseWriter(ctx), &http.Cookie{
			Name:     "refresh_token",
			Value:    refreshToken,
			Path:     "/auth/refresh",
			HttpOnly: true,
			Secure:   r.Config.AppEnv == "production" && !r.Config.CI,
			SameSite: http.SameSiteStrictMode,
			MaxAge:   7 * 24 * 3600, // 7 days
		})
	}

	// 3. Return success payload with token
	return &model1.AuthPayload{
		Success: true,
		Message: "Registration successful.",
		User:    internalUser,
		Token:   token,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model1.LoginInput) (*model1.AuthPayload, error) {
	// ... (User verification logic remains the same) ...
	user, err := r.UserService.VerifyPassword(ctx, input.Email, input.Password)
	if err != nil {
		return nil, fmt.Errorf("invalid login credentials")
	}

	// 1. Generate the JWT token
	token, err := middleware.GenerateJWT(user, r.JWTSecret)
	if err != nil {
		slog.Error("CRITICAL: Failed to generate JWT for user", "user_id", user.ID, "error", err)
		return nil, fmt.Errorf("internal server error during session creation")
	}

	// 2. Generate Refresh Token
	refreshToken, err := r.TokenService.CreateCompositeRefreshToken(ctx, user.ID)
	if err != nil {
		slog.Error("Failed to generate refresh token", "error", err)
	} else {
		http.SetCookie(middleware.GetResponseWriter(ctx), &http.Cookie{
			Name:     "refresh_token",
			Value:    refreshToken,
			Path:     "/auth/refresh",
			HttpOnly: true,
			Secure:   r.Config.AppEnv == "production" && !r.Config.CI,
			SameSite: http.SameSiteStrictMode,
			MaxAge:   7 * 24 * 3600,
		})
	}

	// 2. Return successful payload with token
	return &model1.AuthPayload{
		Success: true,
		Message: "Login successful.",
		User:    user,
		Token:   token,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model1.UpdateUserInput) (*model1.AuthPayload, error) {
	// 1. Ensure user is authenticated
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to update profile")
	}
	userID := userIDVal.(string)

	// ðŸ’¡ STEP 2 (ADAPTER): Map the GraphQL-generated input to the internal, decoupled input model
	internalInput := internalModel.UserUpdateInput{
		CurrentPassword: &input.CurrentPassword,
		NewPassword:     input.NewPassword,
		PreferredUnit:   input.PreferredUnit,
	}

	// 3. Call the UserService with the internal model
	updatedUser, err := r.UserService.UpdateUser(ctx, userID, internalInput)
	if err != nil {
		// This handles "invalid current password" and other service errors
		return nil, err
	}

	// 4. Generate new token for the updated user
	token, err := middleware.GenerateJWT(updatedUser, r.JWTSecret)
	if err != nil {
		slog.Error("CRITICAL: Failed to generate JWT for updated user", "user_id", updatedUser.ID, "error", err)
		return nil, fmt.Errorf("profile updated, but failed to refresh token")
	}

	// 5. Return successful payload
	return &model1.AuthPayload{
		Success: true,
		Message: "User profile updated successfully.",
		User:    updatedUser,
		Token:   token,
	}, nil
}

// Logout is the resolver for the logout field.
// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model1.AuthPayload, error) {
	// 1. Get Refresh Token from Cookie to revoke it
	req := middleware.GetRequest(ctx)
	if req != nil {
		cookie, err := req.Cookie("refresh_token")
		if err == nil {
			// Revoke token in DB
			if err := r.TokenService.Revoke(ctx, cookie.Value); err != nil {
				slog.Warn("Failed to revoke refresh token during logout", "error", err)
			}
		}
	}

	// 2. Clear the refresh cookie
	http.SetCookie(middleware.GetResponseWriter(ctx), &http.Cookie{
		Name:     "refresh_token",
		Value:    "",
		Path:     "/auth/refresh",
		HttpOnly: true,
		Secure:   r.Config.AppEnv == "production" && !r.Config.CI,
		SameSite: http.SameSiteStrictMode,
		MaxAge:   -1,
	})

	return &model1.AuthPayload{
		Success: true,
		Message: "Logged out successfully.",
		Token:   "", // No token returned on logout
	}, nil
}

// CreateUniqueExercise is the resolver for the createUniqueExercise field.
func (r *mutationResolver) CreateUniqueExercise(ctx context.Context, input model1.CreateUniqueExerciseInput) (*internalModel.UniqueExercise, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to create a custom exercise")
	}
	userID := userIDVal.(string)

	// 2. Call Service
	return r.ExerciseService.CreateExercise(ctx, input.Name, input.Description, &userID)
}

// GetWorkoutLog is the resolver for the getWorkoutLog field.
func (r *queryResolver) GetWorkoutLog(ctx context.Context, id string) (*internalModel.WorkoutLog, error) {
	// 1. Fetch from service
	log, err := r.WorkoutService.GetLog(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch workout log: %w", err)
	}
	return log, nil
}

// ListWorkoutLogs is the resolver for the listWorkoutLogs field.
func (r *queryResolver) ListWorkoutLogs(ctx context.Context, limit *int32, offset *int32) ([]*internalModel.WorkoutLog, error) {
	// 1. Get UserID from context
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to list workout logs")
	}
	userID := userIDVal.(string)

	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	// 2. Fetch from service
	logs, err := r.WorkoutService.ListLogs(ctx, userID, l, o)
	if err != nil {
		return nil, fmt.Errorf("failed to list workout logs: %w", err)
	}
	return logs, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*internalModel.User, error) {
	// Use internalModel.User for output

	// 1. Extract the user ID from the context (injected by AuthMiddleware)
	userIDVal := ctx.Value(middleware.UserIDKey)

	// Check if the user ID exists in the context (i.e., user is authenticated)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: authentication required")
	}

	// Assert the type back to a string
	userID, ok := userIDVal.(string)
	if !ok {
		// This should not happen if the middleware is correct, but safe check is good.
		return nil, fmt.Errorf("internal server error: invalid user ID in context")
	}

	// 2. Call the UserService to fetch the complete user entity
	internalUser, err := r.UserService.GetUserByID(ctx, userID)
	if err != nil {
		// Handle "user not found" or database errors
		return nil, fmt.Errorf("failed to retrieve user details: %w", err)
	}

	// 3. Return the internal model directly
	return internalUser, nil
}

// UniqueExercises is the resolver for the uniqueExercises field.
func (r *queryResolver) UniqueExercises(ctx context.Context, query *string, limit *int32, offset *int32) ([]*internalModel.UniqueExercise, error) {
	// 1. Get UserID from context (optional, but needed to see custom exercises)
	var userID *string
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal != nil {
		uid := userIDVal.(string)
		userID = &uid
	}

	// 2. Handle optional args
	q := ""
	if query != nil {
		q = *query
	}
	l := 50
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	// 3. Call Service
	return r.ExerciseService.SearchExercises(ctx, userID, q, l, o)
}

// GetUniqueExercise is the resolver for the getUniqueExercise field.
func (r *queryResolver) GetUniqueExercise(ctx context.Context, id string) (*internalModel.UniqueExercise, error) {
	return r.ExerciseService.GetExercise(ctx, id)
}

// IsCustom is the resolver for the isCustom field.
func (r *uniqueExerciseResolver) IsCustom(ctx context.Context, obj *internalModel.UniqueExercise) (bool, error) {
	return obj.UserID != nil, nil
}

// ExerciseLog returns ExerciseLogResolver implementation.
func (r *Resolver) ExerciseLog() ExerciseLogResolver { return &exerciseLogResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// UniqueExercise returns UniqueExerciseResolver implementation.
func (r *Resolver) UniqueExercise() UniqueExerciseResolver { return &uniqueExerciseResolver{r} }

type exerciseLogResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type uniqueExerciseResolver struct{ *Resolver }
