package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	model1 "github.com/riverajo/fitness-app/backend/graph/model"
	"github.com/riverajo/fitness-app/backend/internal/middleware"
	internalModel "github.com/riverajo/fitness-app/backend/internal/model"
	"github.com/riverajo/fitness-app/backend/internal/util"
	"golang.org/x/crypto/bcrypt"
)

// CreateWorkoutLog is the resolver for the createWorkoutLog field.
func (r *mutationResolver) CreateWorkoutLog(ctx context.Context, input model1.CreateWorkoutLogInput) (*model1.WorkoutLog, error) {
	panic(fmt.Errorf("not implemented: CreateWorkoutLog - createWorkoutLog"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model1.RegisterInput) (*model1.AuthPayload, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to process password: %w", err)
	}
	internalUser := internalModel.NewUserFromRegisterInput(input, string(hashedPassword))
	// 1. Call the UserService to handle hashing and database insertion.
	err = r.UserService.CreateUser(ctx, *internalUser)

	if err != nil {
		// Log the error for internal diagnostics, but return a generic message to the client for security.
		fmt.Printf("Registration failed for email %s: %v\n", input.Email, err)

		// ðŸ’¡ Check for the "user already exists" error (if we want a specific front-end message)
		if err.Error() == fmt.Sprintf("user with email %s already exists", input.Email) {
			return nil, fmt.Errorf("this email is already registered")
		}

		return nil, fmt.Errorf("failed to register user")
	}

	// 2. Registration successful, but we don't handle login/cookie creation here.
	// The client knows registration succeeded. They should call the 'login' mutation next.
	return &model1.AuthPayload{
		Success: true,
		Message: "Registration successful. Please log in.",
		User:    internalUser.ToGraphQLUser(), // Convert the DB model to the safe GraphQL output model
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model1.LoginInput) (*model1.AuthPayload, error) {
	// ... (User verification logic remains the same) ...
	user, err := r.UserService.VerifyPassword(ctx, input.Email, input.Password)
	if err != nil {
		return nil, fmt.Errorf("invalid login credentials")
	}

	// 1. Generate the JWT token
	token, err := util.GenerateJWT(user)
	if err != nil { /* ... handle error ... */
		log.Printf("CRITICAL: Failed to generate JWT for user %s: %v", user.ID.Hex(), err)
		return nil, fmt.Errorf("internal server error during session creation")
	}

	// 2. GET THE RESPONSE WRITER FROM CONTEXT
	w := middleware.GetResponseWriter(ctx)
	if w == nil {
		// Log this critical error internally
		return nil, fmt.Errorf("internal server error: response writer not available")
	}

	// 3. SET THE SECURE HTTP-ONLY COOKIE
	expirationTime := time.Now().Add(24 * time.Hour)
	cookie := http.Cookie{
		Name:     "auth_token",
		Value:    token,
		Expires:  expirationTime,
		HttpOnly: true,                    // Prevents JavaScript access (XSS mitigation)
		Secure:   true,                    // CRITICAL: Only send over HTTPS
		SameSite: http.SameSiteStrictMode, // Prevents CSRF
		Path:     "/",
	}
	http.SetCookie(w, &cookie)

	// 4. Return successful payload
	return &model1.AuthPayload{
		Success: true,
		Message: "Login successful. Token set in cookie.",
		User:    user.ToGraphQLUser(),
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model1.UpdateUserInput) (*model1.AuthPayload, error) {
	// 1. Ensure user is authenticated
	userIDVal := ctx.Value(middleware.UserIDKey)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: must be logged in to update profile")
	}
	userID := userIDVal.(string)

	// ðŸ’¡ STEP 2 (ADAPTER): Map the GraphQL-generated input to the internal, decoupled input model
	internalInput := internalModel.UserUpdateInput{
		CurrentPassword: &input.CurrentPassword,
		NewPassword:     input.NewPassword,
		PreferredUnit:   input.PreferredUnit,
	}

	// 3. Call the UserService with the internal model
	updatedUser, err := r.UserService.UpdateUser(ctx, userID, internalInput)
	if err != nil {
		// This handles "invalid current password" and other service errors
		return nil, err
	}

	// 4. Return successful payload
	return &model1.AuthPayload{
		Success: true,
		Message: "User profile updated successfully.",
		User:    updatedUser.ToGraphQLUser(),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model1.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: Logout - logout"))
}

// GetWorkoutLog is the resolver for the getWorkoutLog field.
func (r *queryResolver) GetWorkoutLog(ctx context.Context, id string) (*model1.WorkoutLog, error) {
	panic(fmt.Errorf("not implemented: GetWorkoutLog - getWorkoutLog"))
}

// ListWorkoutLogs is the resolver for the listWorkoutLogs field.
func (r *queryResolver) ListWorkoutLogs(ctx context.Context) ([]*model1.WorkoutLog, error) {
	panic(fmt.Errorf("not implemented: ListWorkoutLogs - listWorkoutLogs"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model1.User, error) {
	// Use gqlModel.User for output

	// 1. Extract the user ID from the context (injected by AuthMiddleware)
	userIDVal := ctx.Value(middleware.UserIDKey)

	// Check if the user ID exists in the context (i.e., user is authenticated)
	if userIDVal == nil {
		return nil, fmt.Errorf("unauthorized: authentication required")
	}

	// Assert the type back to a string
	userID, ok := userIDVal.(string)
	if !ok {
		// This should not happen if the middleware is correct, but safe check is good.
		return nil, fmt.Errorf("internal server error: invalid user ID in context")
	}

	// 2. Call the UserService to fetch the complete user entity
	internalUser, err := r.UserService.GetUserByID(ctx, userID)
	if err != nil {
		// Handle "user not found" or database errors
		return nil, fmt.Errorf("failed to retrieve user details: %w", err)
	}

	// 3. Return the safe GraphQL output model
	return internalUser.ToGraphQLUser(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
